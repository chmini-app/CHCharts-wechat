var options = { data: [], legend: '{b}', chartRatio: 0, style: null, showLegend: false, showLabel: false, animation: false, showTooltip: false, tooltip: '{b}', area: false, }; function initChart(v1, wcPNAjO2, V3) { switch (this["\x6f\x70\x74\x69\x6f\x6e\x73"]["\x73\x74\x79\x6c\x65"]) { case '\x70\x69\x65': { A(this, v1, wcPNAjO2, V3); break } case '\x72\x6f\x73\x65': { B(this, v1, wcPNAjO2, V3); break } case '\x6c\x69\x6e\x65': { C(this, v1, wcPNAjO2, V3); break } case '\x72\x69\x6e\x67': { D(this, v1, wcPNAjO2, V3); break } case '\x72\x61\x64\x61\x72': { E(this, v1, wcPNAjO2, V3); break } case '\x62\x75\x62\x62\x6c\x65': { F(this, v1, wcPNAjO2, V3); break } case '\x62\x61\x72': { G(this, v1, wcPNAjO2, V3); break } case '\x63\x69\x72\x63\x6c\x65\x73': { H(this, v1, wcPNAjO2, V3); break } case '\x4b\x2d\x6c\x69\x6e\x65': { K(this, v1, wcPNAjO2, V3); break } case '\x67\x61\x75\x67\x65': { J(this, v1, wcPNAjO2, V3); break } case '\x66\x75\x6e\x6e\x65\x6c': { L(this, v1, wcPNAjO2, V3); break } case '\x74\x72\x65\x65\x6d\x61\x70': { M(this, v1, wcPNAjO2, V3); break } default: break } } var barDesc = {}; function G(that, context, width, height) { let param = that.options; const barwidth = width || 200; const barheight = height || 200; const fontSize = 10; const textMinMargin = fontSize / 2; const textAxisMargin = fontSize / 2; const textRowMargin = fontSize / 4; const xWordsCnt = param.xWordsCnt || 3; const xRows = param.xRows || 3; const pdLeft = fontSize * 4 + textAxisMargin; const pdBottom = (fontSize + textRowMargin) * xRows + textAxisMargin; const pdRight = xWordsCnt * fontSize / 2; const pdTop = 15; const x0 = pdLeft; const y0 = barheight - pdBottom; const baseColor = '#333333'; const time = param.animTime || 1000; const bars = param.data || []; const xLabel = param.xLabel || []; const rectStyle = param.rectStyle; const advisedYCnt = 6; const accum = param.accum || false; let accumArr = new Array(); for (let i = 0; i < bars.length; i++) { for (let j = 0; j < bars[i].data.length; j++) { accumArr[j] = 0 } } if (rectStyle == 'accum') { function Gs(valueArray, color, length, xDesc, yDesc) { context.setFillStyle(color); let curX = x0; let curY = y0; let X1, y1, Y1; let rectwidth = 15; curX = x0 + xDesc.startPosOffset - 0.5 * rectwidth; context.beginPath(); context.setGlobalAlpha(1); for (let i = 0; i < length; i++) { curY = ((valueArray[i] - yDesc.bottom) / yDesc.range) * (barheight - pdTop - pdBottom); X1 = curX; y1 = curY; curX += xDesc.span; Y1 = barheight - y1 - pdBottom - accumArr[i]; context.rect(X1, Y1, rectwidth, y1); context.fill(); accumArr[i] += curY } context.closePath() } var YArray = new Array(); let bar_length = bars[0].data.length; for (let i = 0; i < bar_length; i++) { YArray[i] = 0 } for (let i = 0; i < bars.length; i++) { for (let j = 0; j < YArray.length; j++) { YArray[j] += bars[i].data[j] } } let maxarr = YArray[0]; for (let i = 1; i < YArray.length; i++) { if (YArray[i] > maxarr) { maxarr = YArray[i] } } let sumArr = [].concat(...bars.map(function (val) { return val.data })); let yAxis = new YAxis({ height: (barheight - pdTop - pdBottom), width: pdLeft, originX: x0, originY: y0, context: context, dataArray: sumArr, max: maxarr, min: 0, optional: { color: param.yAxis ? param.yAxis.color : null } }); yAxis.draw(); let xAxis = new XAxis({ height: pdBottom, width: (width - pdRight - pdLeft), originX: x0, originY: y0, context: context, dataArray: xLabel, optional: { rowWordsCnt: xWordsCnt, startPadding: 50, endPadding: 50, color: param.xAxis ? param.xAxis.color : null } }); xAxis.draw(); let xDesc = xAxis.getDescriptor(), yDesc = yAxis.getDescriptor(); for (let i = 0; i < bars.length; i++) { Gs(bars[i].data, bars[i].color, xLabel.length, xDesc, yDesc) } barDesc = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom, } } else { let total_width = 20; function Gs(valueArray, color, length, xDesc, yDesc) { context.setFillStyle(color); let curX = x0; let curY = y0; let x1, y1; let rectwidth = total_width / bars.length; curX = x0 + xDesc.startPosOffset - 0.5 * total_width; context.beginPath(); context.setGlobalAlpha(1); for (let i = 0; i < length; i++) { curY = ((valueArray[i] - yDesc.bottom) / yDesc.range) * (barheight - pdTop - pdBottom); x1 = curX; y1 = curY; curX += xDesc.span; context.rect(x1, barheight - y1 - pdBottom, rectwidth, y1); context.fill() } context.closePath() } let sumArr = [].concat(...bars.map(function (val) { return val.data })); let yAxis = new YAxis({ height: (barheight - pdTop - pdBottom), width: pdLeft, originX: x0, originY: y0, context: context, dataArray: sumArr, optional: { color: param.yAxis ? param.yAxis.color : null } }); yAxis.draw(); let xAxis = new XAxis({ height: pdBottom, width: (width - pdRight - pdLeft), originX: x0, originY: y0, context: context, dataArray: xLabel, optional: { rowWordsCnt: xWordsCnt, startPadding: 50, endPadding: 50, color: param.xAxis ? param.xAxis.color : null } }); xAxis.draw(); let xDesc = xAxis.getDescriptor(), yDesc = yAxis.getDescriptor(); let j = total_width / bars.length; for (let i = 0; i < bars.length; i++) { Gs(bars[i].data, bars[i].color, xLabel.length, xDesc, yDesc); xDesc.startPosOffset += j } barDesc = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom, } } context.draw() } function E(that, context, width, height) { if (that.options.data == undefined || that.options.xLabel == undefined) { context.draw(); return } var length = that.options.xLabel.length; if (length <= 2) { context.draw(); return } var ratio = 0.8; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var angle = Math.PI * 2 / length; var step = 1; var MaxStep = that.options.animation ? 50 : 1; var animation = function () { if (step <= MaxStep) { for (var layer = 5; layer > 0; layer--) { context.beginPath(); context.setGlobalAlpha(1); context.setStrokeStyle("#D3D3D3"); if (layer % 2 != 0) { context.setFillStyle("white") } else { context.setFillStyle("#F5F5F5") } var currentRad = layer / 5 * radius; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i < length; i++) { context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle } context.fill(); context.closePath(); context.stroke() } context.beginPath(); var currentAngle = -Math.PI / 2; for (var i = 0; i < length; i++) { context.moveTo(center.x + radius * Math.cos(currentAngle), center.y + radius * Math.sin(currentAngle)); context.lineTo(center.x, center.y); currentAngle += angle } context.closePath(); context.stroke(); context.beginPath(); context.setFillStyle("#D3D3D3"); context.setFontSize(14); var currentAngle = -Math.PI / 2; for (var i = 0; i < length; i++) { var posX = center.x + radius * Math.cos(currentAngle); var posY = center.y + radius * Math.sin(currentAngle); if (posX < center.x) context.setTextAlign("right"); else context.setTextAlign("left"); if (posY > center.y) context.setTextBaseline("top"); else context.setTextBaseline("bottom"); context.fillText(that.options.xLabel[i], posX, posY); currentAngle += angle } context.closePath(); var MaxValue = Math.max.apply(null, that.options.data[0].value); that.options.data.forEach(function (val) { var temp = Math.max.apply(null, val.value); if (temp > MaxValue) MaxValue = temp }); if (MaxValue > 10) { MaxValue = Math.ceil(MaxValue / 10) * 10 } that.options.data.forEach(function (val) { context.beginPath(); context.setStrokeStyle(val.color); var currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i < length; i++) { currentRad = radius * val.value[i] / MaxValue * step / MaxStep; context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle } currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.lineTo(center.x, center.y - currentRad); context.stroke(); if (that.options.area) { context.setFillStyle(val.color); context.setGlobalAlpha(0.5); context.fill() } context.closePath() }); context.draw(); step++ } else { clearInterval(aniName) } }; var aniName = setInterval(animation, 10) } function D(that, context, width, height) { if (that.options.data == undefined) { context.draw(); return } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value }); var step = 1; var MaxStep = that.options.animation ? 50 : 1; var animation = function () { if (step <= MaxStep) { var start = 0; that.options.data.forEach(function (val, idx) { context.beginPath(); context.arc(center.x, center.y, radius, start, start + val.value / MaxStep * step / total * 2 * Math.PI, false); context.setLineWidth(1); context.lineTo(center.x, center.y); context.setStrokeStyle("#ffffff"); context.setFillStyle(val.color); context.fill(); context.closePath(); context.stroke(); context.beginPath(); context.setFillStyle("#ffffff"); context.arc(center.x, center.y, radius * 0.6, start, start + val.value / MaxStep * step / total * 2 * Math.PI, false); context.lineTo(center.x, center.y); context.fill(); context.closePath(); start += val.value / MaxStep * step / total * 2 * Math.PI; if (val.value > 0 && that.options.showLegend) { var midRad = start - val.value / total * Math.PI; var posX = center.x + radius * Math.cos(midRad); var posY = center.y + radius * Math.sin(midRad); context.beginPath(); context.setLineWidth(2); context.setStrokeStyle(val.color); context.moveTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); posY = posY + small * 0.05 * Math.sin(midRad); context.lineTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); context.lineTo(posX, posY); context.setFillStyle(val.color); if (small > 150 && small < 250) { context.setFontSize(10); } else if (small < 150) { context.setFontSize(8); } else { context.setFontSize(14); } context.setTextBaseline("middle"); if (posX < center.x) { context.setTextAlign("right") } else { context.setTextAlign("left") } if (that.options.legend === undefined) { that.options.legend = '{b}' } var txt = that.options.legend.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); context.fillText(txt, posX, posY); context.stroke(); context.closePath() } }); context.draw(); step++ } else { clearInterval(aniName) } }; var aniName = setInterval(animation, 10) } function B(that, context, width, height) { if (that.options.data == undefined) { context.draw(); return } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var maxValue = that.options.data[0].value; var total = 0; that.options.data.forEach(function (val) { total += val.value; maxValue = Math.max(maxValue, val.value) }); var step = 1; var MaxStep = that.options.animation ? 50 : 1; var animation = function () { if (step <= MaxStep) { var start = 0; that.options.data.forEach(function (val, idx) { context.beginPath(); context.arc(center.x, center.y, radius * val.value / MaxStep * step / maxValue, start, start + 2 * Math.PI / that.options.data.length, false); context.setLineWidth(1); context.lineTo(center.x, center.y); context.setStrokeStyle("#ffffff"); context.setFillStyle(val.color); context.fill(); context.closePath(); context.stroke(); start += 2 * Math.PI / that.options.data.length; if (val.value > 0 && that.options.showLegend) { var midRad = start - Math.PI / that.options.data.length; var posX = center.x + radius * val.value / MaxStep * step / maxValue * Math.cos(midRad); var posY = center.y + radius * val.value / MaxStep * step / maxValue * Math.sin(midRad); context.beginPath(); context.setLineWidth(2); context.setStrokeStyle(val.color); context.moveTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); posY = posY + small * 0.05 * Math.sin(midRad); context.lineTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); context.lineTo(posX, posY); context.setFontSize(14); context.setTextBaseline("middle"); if (posX < center.x) { context.setTextAlign("right") } else { context.setTextAlign("left") } if (that.options.legend === undefined) { that.options.legend = '{b}' } var txt = that.options.legend.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); context.fillText(txt, posX, posY); context.stroke(); context.closePath() } }); context.draw(); step++ } else { clearInterval(aniName) } }; var aniName = setInterval(animation, 10) } function A(that, context, width, height) { if (that.options.data == undefined) { context.draw(); return } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var pieCenter = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value }); var step = 1; var MaxStep = that.options.animation ? 50 : 1; var animation = function () { if (step <= MaxStep) { var start = 0; that.options.data.forEach(function (val, idx) { context.beginPath(); context.arc(pieCenter.x, pieCenter.y, radius, start, start + val.value / MaxStep * step / total * 2 * Math.PI, false); context.setLineWidth(1); context.lineTo(pieCenter.x, pieCenter.y); context.setStrokeStyle("#ffffff"); context.setFillStyle(val.color); context.fill(); context.closePath(); context.stroke(); start += val.value / MaxStep * step / total * 2 * Math.PI; if (val.value > 0 && that.options.showLegend) { var midRad = start - val.value / total * Math.PI; var posX = pieCenter.x + radius * Math.cos(midRad); var posY = pieCenter.y + radius * Math.sin(midRad); context.beginPath(); context.setLineWidth(2); context.setStrokeStyle(val.color); context.moveTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); posY = posY + small * 0.05 * Math.sin(midRad); context.lineTo(posX, posY); posX = posX + small * 0.05 * Math.cos(midRad); context.lineTo(posX, posY); context.setFontSize(14); context.setTextBaseline("middle"); if (posX < pieCenter.x) { context.setTextAlign("right") } else { context.setTextAlign("left") } if (that.options.legend === undefined) { that.options.legend = '{b}' } var txt = that.options.legend.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); context.fillText(txt, posX, posY); context.stroke(); context.closePath() } }); context.draw(); step++ } else { clearInterval(aniName) } }; var aniName = setInterval(animation, 10) } function H(that, context, width, height) {
  if (that.options.data == undefined) { context.draw(); return; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var spaceWidth = 3; var lineWidth = radius / that.options.data.length - spaceWidth; if (lineWidth > 20) { lineWidth = 20; } var circlesCenter = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value; });var step = 1; var MaxStep = that.options.animation ? 50 : 1; var animation = function () {
    var radius = small * ratio / 2.0; if (step <= MaxStep && radius > 0) {
      var start = -0.5 * Math.PI; var maxData = that.options.data[0].value
      that.options.data.forEach(function (val, idx) { context.beginPath(); context.arc(circlesCenter.x, circlesCenter.y, radius, start, start + val.value * step / MaxStep / maxData * 1.25 * Math.PI, false); context.setLineWidth(lineWidth); context.setStrokeStyle(val.color); context.stroke(); context.closePath(); if (val.value > 0 && that.options.showLegend && lineWidth > 8) { var posX = circlesCenter.x - 5; var posY = circlesCenter.y - radius + 3; context.setTextAlign("right"); var txt = that.options.legend.replace(/{a}/g, val.name); if (lineWidth > 13) { context.setFontSize(14); } context.fillText(txt, posX, posY); } radius = radius - lineWidth - spaceWidth; }); context.draw(); step++;
    } else { clearInterval(aniName); }
  };var aniName = setInterval(animation, 10);
} var klineDesc = {};function K(that, context, width, height) {
  const param = that.options; const kwidth = width || 200; const kheight = height || 200; const fontSize = 10; const textMinMargin = fontSize / 2; const textAxisMargin = fontSize / 4; const xWordsCnt = param.xWordsCnt || 3; const xRows = param.xRows || 2; const textRowMargin = fontSize / 4; const pdLeft = fontSize * 4 + textAxisMargin; const pdBottom = (fontSize + textRowMargin) * xRows + textAxisMargin; const pdRight = xWordsCnt * fontSize / 2; const pdTop = 15; const x0 = pdLeft; const y0 = kheight - pdBottom; const baseColor = '#333333'; const advisedYCnt = 6; const xLabel = param.xLabel; const total_width = 150; const kdata = param.data || []; const lineData = param.linesData || []; const lw = param.lineWidth || 1; function drawKlines(valueArray, color, length, xDesc, yDesc) {
    context.setFillStyle(color); let X1, Y1, y1, y0; let curX = x0; let curY = y0; let rectwidth = total_width / length; curX = x0 + xDesc.startPosOffset - 0.5 * rectwidth; context.beginPath(); context.setGlobalAlpha(1); X1 = curX; Y1 = yDesc ? (1 - (valueArray[0] - yDesc.bottom) / yDesc.range) * (kheight - pdTop - pdBottom) + pdTop : kheight - pdBottom; y0 = (1 - (valueArray[1] - yDesc.bottom) / yDesc.range) * (kheight - pdTop - pdBottom) + pdTop
    y1 = y0 - Y1; context.rect(X1, Y1, rectwidth, y1); let x1, y2, y3, y4; x1 = X1 + rectwidth / 2; y2 = (1 - (valueArray[3] - yDesc.bottom) / yDesc.range) * (kheight - pdTop - pdBottom) + pdTop; y3 = Y1 + y1; y4 = (1 - (valueArray[2] - yDesc.bottom) / yDesc.range) * (kheight - pdTop - pdBottom) + pdTop
    context.setStrokeStyle(color); context.moveTo(x1, Y1); context.lineTo(x1, y2); context.moveTo(x1, y3); context.lineTo(x1, y4); context.fill(); context.closePath(); context.stroke();
  } function drawLines(valueArray, color, length, xDesc, yDesc) { context.setFillStyle(color); context.setStrokeStyle(color); let curX = x0; let x1, y1; curX = x0 + xDesc.startPosOffset; context.beginPath(); context.setGlobalAlpha(1); for (let i = 0; i < length; i++) { let curY = yDesc ? (1 - (valueArray[i] - yDesc.bottom) / yDesc.range) * (height - pdTop - pdBottom) + pdTop : height - pdBottom; curY = curY || 0; if (i == 0) { context.moveTo(curX, curY); } else { context.bezierCurveTo(curX - xDesc.span / 2, y1, curX - xDesc.span / 2, curY, curX, curY); } x1 = curX; y1 = curY; curX += xDesc.span; } context.stroke(); } let sumArr = [].concat(...kdata.map(function (val) { return val.data })); let maxarr = 0; for (let i = 0; i < sumArr.length; i++) { if (maxarr < sumArr[i]) { maxarr = sumArr[i]; } } let yAxis = new YAxis({ height: (kheight - pdTop - pdBottom), width: pdLeft, originX: x0, originY: y0, max: maxarr, min: 0, context: context, dataArray: sumArr, optional: { lineWidth: lw, color: param.yAxis ? param.yAxis.color : null } }); yAxis.draw(); let startPadding = total_width / xLabel.length; let xAxis = new XAxis({ height: pdBottom, width: (kwidth - pdRight - pdLeft), originX: x0, originY: y0, context: context, dataArray: xLabel, optional: { lineWidth: lw, rowWordsCnt: xWordsCnt, startPadding: startPadding, rowCnt: xRows, color: param.xAxis ? param.xAxis.color : null } });xAxis.draw(); let xDesc = xAxis.getDescriptor(), yDesc = yAxis.getDescriptor();let startPosOffset = xDesc.startPosOffset; for (let i = 0; i < kdata.length; i++) { drawKlines(kdata[i].data, kdata[i].color, xLabel.length, xDesc, yDesc); xDesc.startPosOffset += xDesc.span; } xDesc.startPosOffset = startPosOffset; for (let i = 0; i < lineData.length; i++) { let length = Math.min(xLabel.length, lineData[i].data.length); drawLines(lineData[i].data, lineData[i].color, length, xDesc, yDesc); } klineDesc = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom, }; lineDesc = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom }; context.draw();
} function J(that, context, width, height) { if (that.options.data == undefined) { context.draw(); return; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = 5 / 12 * small * ratio; var circlesCenter = { x: width / 2, y: 7 / 12 * height }; var step = 1; var MaxStep = that.options.animation ? 50 : 1; var title = that.options.data.name; var animation = function () { if (step <= MaxStep) { var val = that.options.data.value * step / MaxStep; var lineWidth = 1 / 4 * radius; var start = -1.25 * Math.PI; var end = -1.109 * Math.PI; var min = that.options.min; var max = that.options.max; var ma = max - min; var mi = val - min; context.beginPath(); context.setFillStyle('#9adbc6'); if (width > 250) { context.setFontSize(14); } else { context.setFontSize(10); } context.fillText(min, 0.7 * radius * Math.cos(start) + circlesCenter.x, 0.7 * radius * Math.sin(start) + circlesCenter.y); context.setTextAlign('center'); for (var i = 0; i < 10; i++) { context.beginPath(); context.arc(circlesCenter.x, circlesCenter.y, radius, start, end, false); context.setLineWidth(lineWidth); if (i < 2) { context.setStrokeStyle("#9adbc6"); } else if (i > 7) { context.setStrokeStyle("#ba082f"); } else { context.setStrokeStyle("#458aa1"); } context.stroke(); var start2 = start + 0.0242 * Math.PI; var end2 = start + 0.0292 * Math.PI; for (var j = 0; j < 5; j++) { context.beginPath(); context.arc(circlesCenter.x, circlesCenter.y, 1.1 * radius, start2, end2, false); context.setLineWidth(0.3 * lineWidth); context.setStrokeStyle("white"); context.stroke(); start2 += 0.0292 * Math.PI; end2 += 0.0292 * Math.PI; } start += 0.151 * Math.PI; end += 0.151 * Math.PI; } context.beginPath(); context.setFillStyle('#ba082f'); if (width > 250) { context.setFontSize(14); } context.fillText(max, 0.7 * radius * Math.cos(0.25 * Math.PI) + circlesCenter.x, 0.7 * radius * Math.sin(0.25 * Math.PI) + circlesCenter.y); context.setTextAlign('center'); var s = -1.25 * Math.PI; var txt = Math.round(that.options.max / 10 + that.options.min); for (var i = 0; i < 9; i++) { context.beginPath(); if (i < 2) { context.setFillStyle("#9adbc6"); } else if (i > 7) { context.setFillStyle("#ba082f"); } else { context.setFillStyle("#458aa1"); } if (width > 250) { context.setFontSize(14); } context.fillText(txt, 0.7 * radius * Math.cos(s + 0.151 * Math.PI) + circlesCenter.x, 0.7 * radius * Math.sin(s + 0.151 * Math.PI) + circlesCenter.y); context.setTextAlign('center'); txt += Math.round((that.options.max - that.options.min) / 10); s += 0.151 * Math.PI; } var enX; var enY; var rad = 0.6 * radius; if (mi < 0.25 / 1.5 * ma) { enX = circlesCenter.x - rad * Math.cos((0.25 - mi / ma * 1.5) * Math.PI); enY = circlesCenter.y + rad * Math.sin((0.25 - mi / ma * 1.5) * Math.PI); } else if (mi > 0.25 / 1.5 * ma && mi <= ma / 2) { enX = circlesCenter.x - rad * Math.cos((mi / ma * 1.5 - 0.25) * Math.PI); enY = circlesCenter.y - rad * Math.sin((mi / ma * 1.5 - 0.25) * Math.PI); } else if (mi > ma / 2 && mi < 1.25 / 1.5 * ma) { enX = circlesCenter.x + rad * Math.cos((1.25 - mi / ma * 1.5) * Math.PI); enY = circlesCenter.y - rad * Math.sin((1.25 - mi / ma * 1.5) * Math.PI); } else { enX = circlesCenter.x + rad * Math.cos((mi / ma * 1.5 - 1.25) * Math.PI); enY = circlesCenter.y + rad * Math.sin((mi / ma * 1.5 - 1.25) * Math.PI); } context.beginPath(); context.arc(circlesCenter.x, circlesCenter.y, 0.1 * lineWidth, 0, 2 * Math.PI); context.moveTo(circlesCenter.x, circlesCenter.y); context.lineTo(enX, enY); context.setLineWidth(0.1 * lineWidth); var color; if (val < ma / 10 * 2 + min) { context.setStrokeStyle('#9adbc6'); } else if (val > ma / 10 * 8 + min) { context.setStrokeStyle('#ba082f'); } else { context.setStrokeStyle('#458aa1'); } context.stroke(); context.beginPath(); context.setFontSize(14); context.setFillStyle('black'); if (that.options.showLabel) { context.fillText(title, circlesCenter.x, circlesCenter.y - 0.3 * radius); context.setTextAlign('center'); } var legtxt = that.options.legend.replace(/{c}/g, ((that.options.data.value - min) / (that.options.max - min) * step / MaxStep * 100).toFixed(2) + '%'); var posX = circlesCenter.x; var posY = circlesCenter.y + 0.8 * radius; if (mi < 0.151 * 2 / 1.5 * ma) { context.setFillStyle('#9adbc6'); } else if (mi > 0.151 * 8 / 1.5 * ma) { context.setFillStyle('#ba082f'); } else { context.setFillStyle('#458aa1'); } if (that.options.showLegend) { context.setFontSize(20); context.fillText(legtxt, posX, posY); } context.draw(); step++; } else { clearInterval(aniName); } };var aniName = setInterval(animation, 10); } function L(that, context, width, height) { if (that.options.data == undefined) { context.draw(); return; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var step = 1; var MaxStep = that.options.animation ? 50 : 1; var data = that.options.data; var h = height / data.length; var max = that.options.max; var min = that.options.min; var w; var animation = function () { if (step <= MaxStep) { if (data[0].value > min) { var w0 = (data[0].value - min) / (max - min) * width; } else { var w0 = 0; } context.setStrokeStyle("white"); context.setLineWidth(3); context.beginPath(); context.moveTo(width / 2, height); context.lineTo((width - w0) / 2, height - h); context.lineTo((width - w0) / 2 + w0, height - h); context.closePath(); context.setFillStyle(data[0].color); context.setFontSize(12); context.fill(); context.stroke(); if (that.options.showLegend) { var posX = width / 2; var posY = height - 1 / 2 * h; context.setTextAlign("center"); var txt = that.options.legend.replace(/{a}/g, data[0].name); if (data[0].value > min) { context.setFillStyle("white"); } else { context.setFillStyle(data[0].color); } context.fillText(txt, posX, posY); } for (var i = 1; i < data.length; i++) { if (data[i].value > min) { w = (data[i].value - min) / (max - min) * step / MaxStep * width; } else { w = 0; } context.beginPath(); context.moveTo((width - w0) / 2, height - h * i); context.lineTo((width - w0) / 2 + w0, height - h * i); context.lineTo((width - w) / 2 + w, height - h * (i + 1)); context.lineTo((width - w) / 2, height - h * (i + 1)); context.lineTo((width - w0) / 2, height - h * i); context.setFillStyle(data[i].color); context.fill(); context.stroke(); if (that.options.showLegend) { var posX = width / 2; var posY = height - i * h - 1 / 2 * h + 5; var txt = that.options.legend.replace(/{a}/g, data[i].name); context.setFontSize(12); if (data[i].value > min) { context.setFillStyle("white"); } else { context.setFillStyle(data[i].color); } context.fillText(txt, posX, posY); } w0 = w; } context.draw(); step++; } else { clearInterval(aniName); } };var aniName = setInterval(animation, 10); } function M(that, context, width, height) {
  if (that.options.data == undefined) { context.draw(); return; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; width = width * ratio + 10
  height = height * ratio
  var data = that.options.data; var total = 0; for (var i = 0; i < data.length; i++) { total += data[i].value; } var x0 = 10; var y0 = 10; function d(i, x0, y0, r) { let w1, h1, x1, y1, posX, posY; if (r) { h1 = height, w1 = data[i].value / total * width; total -= data[i].value; width = width - w1; x1 = x0 + w1; y1 = y0; } else { w1 = width, h1 = data[i].value / total * height; total -= data[i].value; height = height - h1; x1 = x0; y1 = y0 + h1; } context.beginPath(); context.rect(x0, y0, w1, h1); context.setFillStyle(data[i].color); context.fill(); context.setStrokeStyle('white'); context.stroke(); if (data[i].name.replace(/[\u0391-\uFFE5]/g, "a").length * 12 < w1 || i < 10) { context.setFontSize(12); context.setFillStyle(that.options.fontColor); context.fillText(data[i].name, x0 + w1 / 2 - 15, y0 + h1 / 2 + 6); } if (i + 1 < data.length) { d(i + 1, x1, y1, !r) } } d(0, x0, y0, true); context.draw();
} function Axis(param) { if (!param.optional) param.optional = {}; this.width = param.width; this.height = param.height; this.canvasContext = param.context; this.dataArray = param.dataArray; this.max = param.max; this.min = param.min; this.originX = param.originX; this.originY = param.originY; this.baseColor = param.optional.color || '#233333'; this.lineWidth = param.optional.lineWidth || 1; this.shortLineLength = 4; this.fontSize = param.optional.fontSize || 10; this.orientation = param.orientation || 'horizontal'; this.dataType = param.dataType || 'string'; this.textAxisMargin = this.fontSize / 2; this.textMargin = this.fontSize / 2; this.rowWordsCnt = param.optional.rowWordsCnt ? param.optional.rowWordsCnt : this.orientation == 'horizontal' ? 2 : parseInt((this.width - this.lineWidth / 2 - this.textAxisMargin) / this.fontSize) || 1; this.rowMargin = this.fontSize / 4; this.startPadding = param.optional.startPadding || 0; this.endPadding = param.optional.endPadding || 0; this.textWidth = this.orientation == 'horizontal' ? this.fontSize * this.rowWordsCnt : this.width - this.lineWidth / 2 - this.textAxisMargin; this.rowCnt = param.optional.rowCnt ? param.optional.rowCnt : this.orientation == 'horizontal' ? parseInt((this.height - this.lineWidth / 2 - this.textAxisMargin + this.rowMargin) / (this.fontSize + this.rowMargin)) || 1 : 1; this.textHeight = this.orientation == 'horizontal' ? this.height - this.lineWidth / 2 - this.textAxisMargin : (this.fontSize + this.rowMargin) * this.rowCnt - this.rowMargin } Axis.prototype.getDescriptor = function () { if (this.descriptor) { return this.descriptor } let totalLength = (this.orientation == 'horizontal' ? this.width : this.height) - this.startPadding - this.endPadding; const desc = {}; if (this.dataType == 'number') { let max = 0; let min = 0; if (this.max != undefined && this.min != undefined) { max = this.max; min = this.min } else if (this.dataArray && this.dataArray.length) { max = Math.max(...this.dataArray); min = Math.min(...this.dataArray) } if (max == min && max == 0) { return false } const cnt = this.orientation == 'horizontal' ? parseInt(totalLength / (this.textWidth + this.textMargin)) || 1 : parseInt(totalLength / (this.textHeight + this.textMargin)) || 1; let mStep = min >= 0 ? max / cnt : max <= 0 ? -min / cnt : (max - min) / cnt; let pow3 = Math.floor(Math.log10(mStep)); if (mStep < 1) { mStep *= Math.pow(10, -pow3) } let divisor = Math.pow(10, pow3 > 0 ? pow3 : 0); let div = mStep / divisor; let mod = mStep % divisor; desc.step = mod > divisor / 2 ? Math.ceil(div) : mod == 0 ? Math.floor(div) : Math.floor(div) + 0.5; desc.step *= Math.pow(10, pow3); if (pow3 < 0) desc.fixedPoint = 1 - pow3; if (min >= 0) { desc.cnt = 1; desc.top = desc.step; while (desc.top < max) { desc.top += desc.step; desc.cnt++ } desc.bottom = 0 } else if (max <= 0) { desc.top = 0; desc.cnt = 1; desc.bottom = -desc.step; while (desc.bottom > min) { desc.bottom -= desc.step; desc.cnt++ } } else { desc.cnt = 2; desc.top = desc.step; while (desc.top < max) { desc.top += desc.step; desc.cnt++ } desc.bottom = -desc.step; while (desc.bottom > min) { desc.bottom -= desc.step; desc.cnt++ } } desc.range = desc.top - desc.bottom; desc.space = totalLength / desc.cnt; desc.startPosOffset = this.startPadding } else if (this.dataType == 'string') { if (!this.dataArray || !this.dataArray.length || this.dataArray.length == 1) { desc.step = 1; desc.span = totalLength; desc.startPosOffset = totalLength / 2 } else { desc.span = totalLength / (this.dataArray.length - 1); desc.step = this.orientation == 'horizontal' ? Math.ceil((this.textWidth + this.textMargin) / desc.span) : Math.ceil((this.textHeight + this.textMargin) / desc.span); desc.startPosOffset = this.startPadding } } desc.endPadding = this.endPadding; this.descriptor = desc; return desc }; Axis.prototype.draw = function () { if (!this.width || !this.height || !this.canvasContext || (!this.originX && this.originX != 0) || (!this.originY && this.originY != 0)) { return } let context = this.canvasContext; let desc = this.getDescriptor(); let x0 = this.originX, y0 = this.originY; context.save(); context.setLineWidth(this.lineWidth); context.setFontSize(this.fontSize); context.setFillStyle(this.baseColor); context.setStrokeStyle(this.baseColor); context.setGlobalAlpha(1); if (this.orientation == 'horizontal') { context.beginPath(); context.moveTo(x0, y0); context.lineTo(x0 + this.width, y0); context.stroke(); context.setTextAlign('center'); context.setTextBaseline('top') } else { context.beginPath(); context.moveTo(x0, y0); context.lineTo(x0, y0 - this.height); context.stroke(); context.setTextAlign('right'); context.setTextBaseline('middle') } if (this.dataType == 'string') { context.beginPath(); let curPos = this.orientation == 'horizontal' ? x0 + desc.startPosOffset : y0 - desc.startPosOffset; for (let i = 0; i * desc.step < this.dataArray.length; i++) { let name = this.dataArray[i * desc.step]; let itNum = Math.ceil(name.length / this.rowWordsCnt); let rowNum = Math.min(itNum, this.rowCnt); let sPos = 0, ePos = 0; for (let j = 0; j < rowNum; j++) { ePos = sPos + this.rowWordsCnt; if (ePos > name.length) ePos = name.length; let text = ''; if (j == rowNum - 1 && this.rowCnt < itNum) text = name.substring(sPos, ePos - 1) + 'â€¦'; else text = name.substring(sPos, ePos); if (this.orientation == 'horizontal') { context.fillText(text, curPos, y0 + this.textAxisMargin + j * (this.fontSize + this.rowMargin)) } else { context.fillText(text, x0 - this.textAxisMargin, curPos + j * (this.fontSize + this.rowMargin) - (rowNum - 1) * (this.fontSize + this.rowMargin) / 2) } sPos = ePos } if (this.orientation == 'horizontal') { context.moveTo(curPos, y0); context.lineTo(curPos, y0 - this.shortLineLength); curPos += desc.step * desc.span } else { context.moveTo(x0, curPos); context.lineTo(x0 + this.shortLineLength, curPos); curPos -= desc.step * desc.span } context.stroke() } } else if (this.dataType == 'number') { context.beginPath(); if (desc) { for (let i = 0; i <= desc.cnt; i++) { let text = (desc.bottom + desc.step * i); if (desc.fixedPoint && text != 0) text = text.toFixed(desc.fixedPoint); let width0 = context.measureText(text).width; if (width0 > this.textWidth) { let tmp = new Number(text).toExponential(1); if (context.measureText(tmp).width < width0) { text = tmp } } if (this.orientation == 'horizontal') { context.fillText(text, x0 + desc.startPosOffset + desc.space * i, y0 + this.textAxisMargin); context.moveTo(x0 + desc.startPosOffset + desc.space * i, y0); context.lineTo(x0 + desc.startPosOffset + desc.space * i, y0 - this.shortLineLength) } else { context.fillText(text, x0 - this.textAxisMargin, y0 - desc.startPosOffset - desc.space * i); context.moveTo(x0, y0 - desc.startPosOffset - desc.space * i); context.lineTo(x0 + this.shortLineLength, y0 - desc.startPosOffset - desc.space * i) } context.stroke() } } else { if (this.orientation == 'horizontal') { context.fillText('0', x0 + desc.startPosOffset, y0 + this.textAxisMargin); context.moveTo(x0 + desc.startPosOffset, y0); context.lineTo(x0 + desc.startPosOffset, y0 - this.shortLineLength) } else { context.fillText('0', x0 - this.textAxisMargin, y0 - desc.startPosOffset); context.moveTo(x0, y0 - desc.startPosOffset); context.lineTo(x0 + this.shortLineLength, y0 - desc.startPosOffset) } } } context.restore() }; function YAxis(param) { param.orientation = 'vertical'; param.dataType == undefined ? (param.dataArray instanceof Array && param.dataArray.length > 0) ? param.dataType = typeof param.dataArray[0] : null : null; Axis.call(this, param) } YAxis.prototype = Axis.prototype; function XAxis(param) { param.orientation = 'horizontal'; param.dataType == undefined ? (param.dataArray instanceof Array && param.dataArray.length > 0) ? param.dataType = typeof param.dataArray[0] : null : null; Axis.call(this, param) } XAxis.prototype = Axis.prototype; var lineDesc = {}; function C(that, context, _width, _height) { let param = that.options; const width = _width || 200; const height = _height || 200; const fontSize = 10; const xWordsCnt = param.xWordsCnt || 3; const xRows = param.xRows || 3; const lw = param.lineWidth || 1; const dotRadius = lw * 2; const pdLeft = fontSize * (4 + 0.5) + lw / 2; const pdBottom = fontSize * (1 + 0.25 + 0.5) * xRows + lw / 2; const pdRight = xWordsCnt * fontSize / 2; const pdTop = 15; const x0 = pdLeft; const y0 = height - pdBottom; const time = param.animTime || 1000; const lines = param.data || []; const xLabel = param.xLabel || []; const lineStyle = param.lineStyle || 'line'; const area = param.area || false; function Cs(valueArray, color, length, xDesc, yDesc) { context.setFillStyle(color); context.setStrokeStyle(color); let curX = x0; curX = x0 + xDesc.startPosOffset; context.beginPath(); context.setGlobalAlpha(1); let x1, y1; for (let i = 0; i < length; i++) { let curY = yDesc ? (1 - (valueArray[i] - yDesc.bottom) / yDesc.range) * (height - pdTop - pdBottom) + pdTop : height - pdBottom; curY = curY || 0; if (i == 0) { context.moveTo(curX, curY) } else { if (lineStyle == 'line') context.lineTo(curX, curY); else if (lineStyle == 'curve') context.bezierCurveTo(curX - xDesc.span / 2, y1, curX - xDesc.span / 2, curY, curX, curY) } x1 = curX; y1 = curY; curX += xDesc.span } context.stroke(); if (area) { context.setGlobalAlpha(0.1); context.lineTo(curX - xDesc.span, height - pdBottom); context.lineTo(x0 + xDesc.startPosOffset, y0); context.fill() } } let sumArr = [].concat(...lines.map(function (val) { return val.data })); let yAxis = new YAxis({ height: (height - pdTop - pdBottom), width: pdLeft, originX: x0, originY: y0, context: context, dataArray: sumArr, optional: { lineWidth: lw, fontSize: fontSize, color: param.yAxis ? param.yAxis.color : null } }); yAxis.draw(); let xAxis = new XAxis({ height: pdBottom, width: (width - pdRight - pdLeft), originX: x0, originY: y0, context: context, dataArray: xLabel, optional: { lineWidth: lw, fontSize: fontSize, rowWordsCnt: xWordsCnt, rowCnt: xRows, color: param.xAxis ? param.xAxis.color : null } }); xAxis.draw(); let xDesc = xAxis.getDescriptor(), yDesc = yAxis.getDescriptor(); for (let i = 0; i < lines.length; i++) { let length = Math.min(xLabel.length, lines[i].data.length); Cs(lines[i].data, lines[i].color, length, xDesc, yDesc) } context.draw(); lineDesc = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom } } var bubble_coor = {}; function F(that, context, _width, _height) { if (that.options.data == undefined) { context.draw(); return } let param = that.options; const width = _width || 200; const height = _height || 200; const fontSize = 10; const textMinMargin = fontSize / 2; const textAxisMargin = fontSize / 2; const textRowMargin = fontSize / 4; const xWordsCnt = param.xWordsCnt || 2; const xRows = param.xRows || 3; const lw = param.lineWidth || 1; const dotRadius = lw * 2; const pdLeft = fontSize * 4 + textAxisMargin; const pdBottom = (fontSize + textRowMargin) * xRows + textAxisMargin; const pdRight = xWordsCnt * fontSize / 2; const pdTop = 15; const x0 = pdLeft; const y0 = height - pdBottom; const data = param.data || []; const xLabel = param.xLabel || []; let ymin, ymax, numMin, numMax, item, obj, yLabel = []; let numArr = []; let bubleIndex = 0; let points = []; let r, h; if (!data.length) return; for (var i = 0; i < data.length; i++) { item = data[i]; if (!item.value || !item.value.length) { data.splice(i--, 1); continue } item.name = item.name || 'unnamed'; if (item.hide) continue; numArr = numArr.concat(item.value); yLabel = yLabel.concat(item.yLabel) } numMax = Math.max.apply(null, numArr); numMin = Math.min.apply(null, numArr); let yDis = height - pdTop - pdBottom; let xDis = width - pdRight - pdLeft; let yAxis = new YAxis({ height: yDis, width: pdLeft, originX: x0, originY: y0, context: context, dataArray: yLabel, optional: { color: param.yAxis ? param.yAxis.color : null } }); yAxis.draw(); let padding = 20; let xAxis = new XAxis({ height: pdBottom, width: xDis, originX: x0, originY: y0, context: context, dataArray: xLabel, optional: { rowWordsCnt: xWordsCnt, startPadding: padding, endPadding: padding, color: param.xAxis ? param.xAxis.color : null } }); xAxis.draw(); let xDesc = xAxis.getDescriptor(); let yDesc = yAxis.getDescriptor(); let xs = xDesc.span; ymin = yDesc.bottom; ymax = yDesc.top; for (var i = 0; i < data.length; i++) { item = data[i]; if (!points[i]) { obj = Object.assign({}, { i: bubleIndex, isStop: true, create: true, hide: !!item.hide, name: item.name, color: item.color, hsl: item.hsl, data: [] }); let y = item.yLabel; for (var j = 0; j < Math.min.apply(null, [item.value.length, xLabel.length, y.length]); j++) { h = Math.floor((y[j] - ymin) / (ymax - ymin) * yDis); r = getRadius(numMax, numMin, item.value[j]); let point = {}; point.value = item.value[j]; point.h = h; point.p = h; point.x = j * xs + padding; point.y = h; point.radius = r; point.r = 0; obj.data.push(point) } points.push(obj); bubleIndex++ } } function getRadius(numMax, numMin, num) { var r1 = Math.ceil(num / numMax * xs / 3); var r2 = Math.ceil(num / numMin * 2); return Math.max(r2 > xs / 2 ? r1 : r2, 1) } context.save(); context.translate(x0, y0); let isStop = true; for (var i = 0, l = points.length; i < l; i++) { item = points[i]; item.isStop = true; context.strokeStyle = item.color; context.shadowColor = item.color; let point = {}; for (var j = 0, jl = item.data.length; j < jl; j++) { point = item.data[j]; context.beginPath(); context.setGlobalAlpha = 0.7; context.fillStyle = item.color; context.arc(point.x, -point.y, point.radius, 0, Math.PI * 2, false); context.fill(); context.stroke() } if (!item.isStop) { isStop = false } } context.restore(); context.draw(); bubble_coor = { xDesc: xDesc, yDesc: yDesc, paddingLeft: pdLeft, paddingRight: pdRight, paddingTop: pdTop, paddingBottom: pdBottom, points: points } } function requestTooltip(Sv1, $$kLa2, lIvFAZ3, ErTd4) { switch (this["\x6f\x70\x74\x69\x6f\x6e\x73"]["\x73\x74\x79\x6c\x65"]) { case '\x70\x69\x65': { return AA(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x72\x6f\x73\x65': { return BB(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x6c\x69\x6e\x65': { return CC(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x72\x69\x6e\x67': { return DD(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x72\x61\x64\x61\x72': { return EE(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x62\x75\x62\x62\x6c\x65': { return FF(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x62\x61\x72': { return GG(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x63\x69\x72\x63\x6c\x65\x73': { return HH(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x4b\x2d\x6c\x69\x6e\x65': { return KK(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x67\x61\x75\x67\x65': { return JJ(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x66\x75\x6e\x6e\x65\x6c': { return LL(this, Sv1, $$kLa2, lIvFAZ3, ErTd4) } case '\x74\x72\x65\x65\x6d\x61\x70': { return MM(this, Sv1, $$kLa2, lIvFAZ3, ErTd4);break } default: return {} } } function calculateEucDis(x1, y1, x2, y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) } function calculateAng(x, y, cX, cY) { var a = Math.acos((x - cX) / calculateEucDis(x, y, cX, cY)); if (y < cY) { a = 2 * Math.PI - a } return a } function GG(that, posX, posY, width, height) { if (!that.options.showTooltip) { return {} } let toolTipInfo = {}; toolTipInfo.showTooltip = true; let top = posY; if (posY < barDesc.paddingTop) top = barDesc.paddingTop; else if (posY > height - barDesc.paddingBottom) top = height - barDesc.paddingBottom; let tranX = posX - barDesc.paddingLeft - barDesc.xDesc.startPosOffset; if (posX < barDesc.paddingLeft + barDesc.xDesc.startPosOffset) tranX = 0; else if (posX > (width - barDesc.paddingRight)) tranX = (width - barDesc.paddingRight - barDesc.paddingLeft - barDesc.xDesc.startPosOffset); let dataIndex = Math.round(tranX / barDesc.xDesc.span); let left = parseInt(dataIndex * barDesc.xDesc.span + barDesc.paddingLeft + barDesc.xDesc.startPosOffset); toolTipInfo.tooltipPos = 'left:10px;' + 'right:0px;' + 'top:10px;' + 'font-size:14px'; toolTipInfo.tooltipInfo = ''; if (that.options && that.options.data) { that.options.data.forEach(function (val) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } if (val.data[dataIndex]) { var txt = that.options.tooltip.replace(/{b}/g, val.data[dataIndex]); txt = txt.replace(/{a}/g, val.name); toolTipInfo.tooltipInfo += txt + ' ' } }) } if (toolTipInfo.tooltipInfo.length == 0) toolTipInfo.showTooltip = false; return toolTipInfo } function CC(that, posX, posY, width, height) { if (!that.options.showTooltip) { return {} } let toolTipInfo = {}; toolTipInfo.showTooltip = true; toolTipInfo.showHLine = true; toolTipInfo.showVLine = true; let top = posY; if (posY < lineDesc.paddingTop) top = lineDesc.paddingTop; else if (posY > height - lineDesc.paddingBottom) top = height - lineDesc.paddingBottom; toolTipInfo.crossHLine = 'width:' + (width - lineDesc.paddingLeft - lineDesc.paddingRight) + 'px;' + 'left:' + lineDesc.paddingLeft + 'px;' + 'top:' + top + 'px;'; let tranX = posX - lineDesc.paddingLeft - lineDesc.xDesc.startPosOffset; if (posX < lineDesc.paddingLeft + lineDesc.xDesc.startPosOffset) tranX = 0; else if (posX > (width - lineDesc.paddingRight - (lineDesc.xDesc.endPadding || 0))) tranX = (width - lineDesc.paddingRight - lineDesc.paddingLeft - lineDesc.xDesc.startPosOffset - (lineDesc.xDesc.endPadding || 0)); let dataIndex = Math.round(tranX / lineDesc.xDesc.span); let left = parseInt(dataIndex * lineDesc.xDesc.span + lineDesc.paddingLeft + lineDesc.xDesc.startPosOffset); toolTipInfo.crossVLine = 'height:' + (height - lineDesc.paddingBottom - lineDesc.paddingTop) + 'px;' + 'left:' + left + 'px;' + 'top:' + lineDesc.paddingTop + 'px;'; toolTipInfo.tooltipPos = (left > width / 2 ? 'left:0px;' : 'right:0px;') + 'top:0px;' + 'font-size:14px'; toolTipInfo.tooltipInfo = ''; if (that.options && that.options.data) { that.options.data.forEach(function (val) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } if (val.data[dataIndex]) { var txt = that.options.tooltip.replace(/{b}/g, val.data[dataIndex]); txt = txt.replace(/{a}/g, val.name); toolTipInfo.tooltipInfo += txt + ' ' } }) } if (toolTipInfo.tooltipInfo.length == 0) toolTipInfo.showTooltip = false; return toolTipInfo } function FF(that, posX, posY, canvasWidth, canvasHeight) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {} } let ret = {}; if (posY > bubble_coor.paddingTop && posY < canvasHeight - bubble_coor.paddingBottom && posX > bubble_coor.paddingLeft - 10 && posX < canvasWidth + bubble_coor.paddingLeft) { let clicked_point = { x: posX - bubble_coor.paddingLeft, y: -posY + (canvasHeight - bubble_coor.paddingBottom), }; for (var i = 0, item, l = bubble_coor.points.length; i < l; i++) { item = bubble_coor.points[i]; if (item.hide) continue; for (var j = 0, obj, jl = item.data.length; j < jl; j++) { obj = item.data[j]; var dis = calculateEucDis(clicked_point.x, clicked_point.y, obj.x, obj.y); if (dis < Math.max(obj.radius, 4)) { ret.showTooltip = true; let txt = that.options.tooltip.replace(/{b}/g, obj.value); txt = txt.replace(/{a}/g, item.name); ret.tooltipInfo = txt; let position = { x: clicked_point.x + bubble_coor.paddingLeft, y: -clicked_point.y + (canvasHeight - bubble_coor.paddingBottom), }; ret.tooltipPos = (position.x > canvasWidth / 2 ? 'left:0px;' : 'right:0px;') + 'top:0px;' + 'font-size:14px'; break } } } return ret } } function BB(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {} } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var maxValue = that.options.data[0].value; var total = 0; that.options.data.forEach(function (val) { total += val.value; maxValue = Math.max(maxValue, val.value) }); var dis = calculateEucDis(posX, posY, center.x, center.y); var ret = {}; var angle = calculateAng(posX, posY, center.x, center.y); var rem = 0; for (var i = 0; i < that.options.data.length; i++) { var val = that.options.data[i]; rem += 2 * Math.PI / that.options.data.length; if (rem > angle) { if (dis < val.value / maxValue * radius) { ret.showTooltip = true } if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } var txt = that.options.tooltip.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); ret.tooltipInfo = txt; break } } if (posX < center.x) { ret.tooltipPos = 'left:' + (posX + 10) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 10) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY + 20) + 'px'; return ret } function EE(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {} } var length = that.options.xLabel.length; var ratio = 0.8; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var angle = Math.PI * 2 / length; var dis = calculateEucDis(posX, posY, center.x, center.y); if (dis > radius) { return {} } var closeIndex = 0; var closeDis = calculateEucDis(posX, posY, center.x, center.y - radius); var currentAngle = -Math.PI / 2; for (var i = 1; i < length; i++) { currentAngle += angle; var temp = calculateEucDis(posX, posY, center.x + radius * Math.cos(currentAngle), center.y + radius * Math.sin(currentAngle)); if (temp < closeDis) { closeIndex = i; closeDis = temp } } var ret = {}; ret.showTooltip = true; ret.tooltipInfo = ''; that.options.data.forEach(function (val) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } var txt = that.options.tooltip.replace(/{b}/g, val.value[closeIndex]); txt = txt.replace(/{a}/g, val.name); ret.tooltipInfo += txt + ' ' }); var tipPosX = center.x + radius * Math.cos(-Math.PI / 2 + closeIndex * angle); var tipPoxY = center.y + radius * Math.sin(-Math.PI / 2 + closeIndex * angle); if (tipPosX < center.x) { ret.tooltipPos = 'left:' + (tipPosX) + 'px;' } else { ret.tooltipPos = 'right:' + (width - tipPosX) + 'px;' } ret.tooltipPos += 'bottom:' + (height - tipPoxY) + 'px'; return ret } function DD(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {} } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var center = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value }); var dis = calculateEucDis(posX, posY, center.x, center.y); if (dis > radius || dis < 0.6 * radius) { return {} } var ret = {}; ret.showTooltip = true; var angle = calculateAng(posX, posY, center.x, center.y); var rem = 0; for (var i = 0; i < that.options.data.length; i++) { var val = that.options.data[i]; rem += val.value / total * 2 * Math.PI; if (rem > angle) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } var txt = that.options.tooltip.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); ret.tooltipInfo = txt; break } } if (posX < center.x) { ret.tooltipPos = 'left:' + (posX + 10) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 10) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY + 20) + 'px'; return ret } function AA(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {} } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var pieCenter = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value }); if (calculateEucDis(posX, posY, pieCenter.x, pieCenter.y) > radius) { return {} } var ret = {}; ret.showTooltip = true; var angle = calculateAng(posX, posY, pieCenter.x, pieCenter.y); var rem = 0; for (var i = 0; i < that.options.data.length; i++) { var val = that.options.data[i]; rem += val.value / total * 2 * Math.PI; if (rem > angle) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}' } var txt = that.options.tooltip.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); ret.tooltipInfo = txt; break } } if (posX < pieCenter.x) { ret.tooltipPos = 'left:' + (posX + 10) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 10) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY + 20) + 'px'; return ret } function HH(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {}; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var circlesCenter = { x: width / 2.0, y: height / 2.0 }; var total = 0; that.options.data.forEach(function (val) { total += val.value; });if (calculateEucDis(posX, posY, circlesCenter.x, circlesCenter.y) > radius) { return {}; } var ret = {}; ret.showTooltip = true; var romate = calculateEucDis(posX, posY, circlesCenter.x, circlesCenter.y); var angle = calculateAng(posX, posY, circlesCenter.x, circlesCenter.y); if (angle > 1.5 * Math.PI) { angle -= 1.5 * Math.PI; } else { angle += 0.5 * Math.PI; } var rem = small * ratio / 2.0; var ang = 0; for (var i = 0; i < that.options.data.length; i++) { var val = that.options.data[i]; rem -= 20; if (romate > rem + 5 && romate < rem + 20 && angle < ang + val.value / that.options.data[0].value * 1.25 * Math.PI) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}'; } var txt = that.options.tooltip.replace(/{b}/g, val.value); txt = txt.replace(/{a}/g, val.name); txt = txt.replace(/{c}/g, (val.value / total * 100).toFixed(2) + '%'); ret.tooltipInfo = txt; break; } } if (posX < circlesCenter.x) { ret.tooltipPos = 'left:' + (posX + 10) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 10) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY + 30) + 'px'; if (ret.tooltipInfo) { return ret; } else { return {}; } } function JJ(that, posX, posY, width, height) {
  if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {}; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var small = width > height ? height : width; var radius = small * ratio / 2.0; var circlesCenter = { x: width / 2, y: 7 / 12 * height }; if (calculateEucDis(posX, posY, circlesCenter.x, circlesCenter.y) > radius) { return {}; } var ret = {}; ret.showTooltip = true; var romate = calculateEucDis(posX, posY, circlesCenter.x, circlesCenter.y); var angle = calculateAng(posX, posY, circlesCenter.x, circlesCenter.y); var mi = that.options.data.value - that.options.min; var ma = that.options.max - that.options.min; var currentangle = (mi / ma * 1.5 + 0.75) * Math.PI
  var range = { min: (mi / ma * 1.5 + 0.75 - 1 / 10 * 1.5) * Math.PI, max: (mi / ma * 1.5 + 0.75 + 1 / 10 * 1.5) * Math.PI };if (romate <= 0.7 * radius && angle > range.min && angle < range.max) { var txt = that.options.tooltip.replace(/{b}/g, that.options.data.value); txt = txt.replace(/{a}/g, that.options.data.name); txt = txt.replace(/{c}/g, (that.options.data.value / that.options.max * 100).toFixed(2) + '%'); ret.tooltipInfo = txt; } ret.tooltipPos = 'left:' + 0.3 * width + 'px;';ret.tooltipPos += 'bottom:' + 0.8 * height + 'px'; if (ret.tooltipInfo) { return ret; } else { return {}; }
} function LL(that, posX, posY, width, height) { if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {}; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; var ret = {}; var data = that.options.data; var h = height / data.length; var max = that.options.max; var min = that.options.min; var w0 = data[0].value / (max - min) * width; var w; ret.showTooltip = true; var maxdata = data[data.length - 1].value; if (posY <= height && posY >= height - h && posX > (width - w0) / 2 && posX < (width - w0) / 2 + w0) { var txt = that.options.tooltip.replace(/{a}/g, data[0].name); txt = txt.replace(/{c}/g, Math.floor(100 * 100 * data[0].value / maxdata) / 100 + '%'); txt = txt.replace(/{b}/g, data[0].value); } for (var i = 1; i < data.length; i++) { w = data[i].value / (max - min) * width; if (posY < height - h * i && posY >= height - h * (i + 1) && posX > (width - w) / 2 && posX < (width - w) / 2 + w) { var txt = that.options.tooltip.replace(/{a}/g, data[i].name); txt = txt.replace(/{b}/g, data[i].value); txt = txt.replace(/{c}/g, Math.floor(100 * 100 * data[i].value / maxdata) / 100 + '%'); break; } } ret.tooltipInfo = txt; if (posY > 2 * height / 9) { if (posX < width / 2) { ret.tooltipPos = 'left:' + (posX - 10) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 10) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY + 30) + 'px'; } else { if (posX < width / 2) { ret.tooltipPos = 'left:' + (posX + 30) + 'px;' } else { ret.tooltipPos = 'right:' + (width - posX + 50) + 'px;' } ret.tooltipPos += 'bottom:' + (height - posY - 50) + 'px'; } if (ret.tooltipInfo) { return ret; } else { return {}; } } function MM(that, posX, posY, width, height) {
  if (that.options.showTooltip == undefined || that.options.showTooltip == false) { return {}; } var ratio = width > height ? 0.8 : 0.5; if (!that.options.showLegend) ratio = 1; if (that.options.chartRatio > 0 && that.options.chartRatio <= 1) ratio = that.options.chartRatio; width = width * ratio
  height = height * ratio
  var ret = {}; var data = that.options.data; ret.showTooltip = true; var x0 = 10; var y0 = 10; var total = 0; for (var i = 0; i < data.length; i++) { total += data[i].value; } var sum = total; function t(i, x0, y0, r) {
    let w1, h1, x1, y1; if (r) { h1 = height, w1 = data[i].value / total * width; total -= data[i].value; width = width - w1; x1 = x0 + w1; y1 = y0; } else {
    w1 = width, h1 = data[i].value / total * height; total -= data[i].value; height = height - h1
      x1 = x0; y1 = y0 + h1;
    } if (posY <= y0 + h1 && posY >= y0 && posX >= x0 && posX <= x0 + w1) { var txt = that.options.tooltip.replace(/{a}/g, data[i].name); txt = txt.replace(/{b}/g, data[i].value); txt = txt.replace(/{c}/g, Math.floor(100 * 100 * data[i].value / sum) / 100 + '%');ret.tooltipInfo = txt; ret.tooltipPos += 'bottom:' + (height - 20) + 'px'; ret.tooltipPos = 'left:' + w1 / 2 + 'px;';return } if (i + 1 < data.length) { t(i + 1, x1, y1, !r) }
  } t(0, x0, y0, true); if (ret.tooltipInfo) { return ret; } else { return {}; }
} function KK(that, posX, posY, kwidth, kheight) { if (!that.options.showTooltip) { return {}; } let toolTipInfo = {}; toolTipInfo.showTooltip = true; toolTipInfo.showHLine = true; toolTipInfo.showVLine = true; let top = posY; if (posY < klineDesc.paddingTop) top = klineDesc.paddingTop; else if (posY > kheight - klineDesc.paddingBottom) top = kheight - klineDesc.paddingBottom; toolTipInfo.crossHLine = 'width:' + (kwidth - klineDesc.paddingLeft - klineDesc.paddingRight) + 'px;' + 'left:' + klineDesc.paddingLeft + 'px;' + 'top:' + top + 'px;'; let tranX = posX - klineDesc.paddingLeft - klineDesc.xDesc.startPosOffset; if (posX < klineDesc.paddingLeft + klineDesc.xDesc.startPosOffset) tranX = 0; else if (posX > (kwidth - klineDesc.paddingRight)) tranX = (kwidth - klineDesc.paddingRight - klineDesc.paddingLeft - klineDesc.xDesc.startPosOffset); let dataIndex = Math.round(tranX / klineDesc.xDesc.span); let left = parseInt(dataIndex * klineDesc.xDesc.span + klineDesc.paddingLeft + klineDesc.xDesc.startPosOffset); toolTipInfo.crossVLine = 'height:' + (kheight - klineDesc.paddingBottom - klineDesc.paddingTop) + 'px;' + 'left:' + left + 'px;' + 'top:' + klineDesc.paddingTop + 'px;'; toolTipInfo.tooltipPos = (left > kwidth / 2 ? 'left:0px;' : 'right:0px;') + 'top:0px;' + 'font-size:14px'; toolTipInfo.tooltipInfo = ''; if (that.options && that.options.data) { that.options.data.forEach(function (val, index) { if (that.options.tooltip === undefined) { that.options.tooltip = '{b}'; } if (index == dataIndex) { for (var i = 0; i < val.name.length; i++) { var txt = that.options.tooltip.replace(/{b}/g, val.data[i]); txt = txt.replace(/{a}/g, val.name[i]); toolTipInfo.tooltipInfo += txt + ' '; } } }); } if (toolTipInfo.tooltipInfo.length == 0) toolTipInfo.showTooltip = false; return toolTipInfo; } module.exports = { options: options, initChart: initChart, requestTooltip: requestTooltip, }